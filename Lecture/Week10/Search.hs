module Search where

myElem :: Eq a => a -> [a] -> Bool
myElem x list = case list of
  [] -> False
  y:ys -> x == y || myElem x ys

data BSTree a = Null | Node (BSTree a) a (BSTree a)
  deriving Show

bSElem :: Ord a => a -> BSTree a -> Bool
bSElem x tree = case tree of
  Null -> False
  Node left node right
    | x < node  -> bSElem x left
    | x == node -> True
    | otherwise -> bSElem x right

-- | buildBalanced
-- 
-- Builds a balanced Binary Search Tree,
-- using values in the range between its inputs

buildBalanced ::  Integral a => a -> a -> BSTree a
buildBalanced start end
  | start > end = Null
  | otherwise = Node (buildBalanced start (middle-1))
                     middle
                     (buildBalanced (middle+1) end)
      where
        middle = div (start + end) 2

veryBigNumber :: Integer
veryBigNumber =
  1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
